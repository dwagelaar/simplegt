-- @atlcompiler emftvm
-- @nsURI Problem=http://soft.vub.ac.be/simplegt/2011/Problem
-- @nsURI SimpleGT=http://soft.vub.ac.be/simplegt/2011/SimpleGT
-- @nsURI EMFTVM=http://soft.vub.ac.be/emftvm/2011/EMFTVM
-- Translates SimpleGT transformations to EMFTVM
-- $Id$
module SimpleGTtoEMFTVM;

create OUT : EMFTVM, PBS : Problem from IN : SimpleGT;

-- ======================================================================
-- helpers begin
-- ======================================================================

--helper def : SetType : String		= 'be.ac.vub.emftvm.util.LazySet';
--helper def : BagType : String		= 'be.ac.vub.emftvm.util.LazyBag';
--helper def : SequenceType : String	= 'be.ac.vub.emftvm.util.LazyList';
--helper def : OrderedSetType : String= 'be.ac.vub.emftvm.util.LazyOrderedSet';

helper context SimpleGT!InputElementPattern def : patternFor : SimpleGT!Rule =
	OclUndefined;

helper context SimpleGT!InPattern def : patternFor : SimpleGT!Rule =
	self.inputFor;

helper context SimpleGT!NacPattern def : patternFor : SimpleGT!Rule =
	self.nacFor;

helper context SimpleGT!OutPattern def : patternFor : SimpleGT!Rule =
	self.outputFor;

helper context SimpleGT!Rule def : allInputPatterns : Sequence(SimpleGT!InputElementPattern) =
	if self.input.oclIsUndefined() then
		Sequence{}
	else
		Sequence{self.input}
	endif
	->union(self.nac);

-- Returns 'true' if any contained rule elements have bindings.
helper context SimpleGT!InputElementPattern def : hasBindings : Boolean =
	self.elements->exists(e|e.bindings->notEmpty());

-- Returns all bindings contained in rule elements of this pattern.
helper context SimpleGT!InputElementPattern def : bindings : Sequence(SimpleGT!InputBinding) =
	self.elements->collect(e|e.bindings)->flatten();

-- Returns 'true' if any contained rule elements have bindings.
helper context SimpleGT!OutPattern def : hasBindings : Boolean =
	self.elements->exists(e|e.bindings->notEmpty());

-- Returns all bindings contained in rule elements of this pattern.
helper context SimpleGT!OutPattern def : bindings : Sequence(SimpleGT!OutputBinding) =
	self.elements->collect(e|e.bindings)->flatten();

-- Returns 'true' if the input pattern rule elements have bindings.
helper context SimpleGT!Rule def : hasInputBindings : Boolean =
	self.inputElements->exists(p|p.bindings->notEmpty());

-- Returns all bindings contained in rule elements of the input pattern or any nac pattern.
--helper context SimpleGT!Rule def : inputBindings : Sequence(SimpleGT!InputBinding) =
--	self.allInputPatterns->collect(p|p.bindings)->flatten();

-- Returns the next input binding, if any.
--helper context SimpleGT!InputBinding def : next : SimpleGT!InputBinding =
--	let bindings : Sequence(SimpleGT!InputBinding) = 
--		self.element.pattern.patternFor.inputBindings
--	in bindings->at(bindings->indexOf(self) + 1);

--helper context SimpleGT!Expression def : refersTo(e : SimpleGT!RuleElement) : Boolean =
--	false;
--
--helper context SimpleGT!ElementExp def : refersTo(e : SimpleGT!RuleElement) : Boolean =
--	self.element = e;

--helper context SimpleGT!InputElement def : hasDefBinding : SimpleGT!InputBinding =
--	self.pattern.patternFor.inputBindings->select(b|b.expr.refersTo(self))->size() = 1;
--
--helper context SimpleGT!InputElement def : defBinding : SimpleGT!InputBinding =
--	self.pattern.patternFor.inputBindings->select(b|b.expr.refersTo(self))->first();

-- Returns input elements contained in the input pattern, if any.
helper context SimpleGT!Rule def : inputElements : Sequence(SimpleGT!InputElement) =
	if self.input.oclIsUndefined() then Sequence{}
	else self.input.elements endif;

-- Returns the output elements contained in the output pattern, if any.
helper context SimpleGT!Rule def : outputElements : Sequence(SimpleGT!OutputElement) =
	if self.output.oclIsUndefined() then Sequence{}
	else self.output.elements endif;

-- Returns the new output elements contained in the output pattern, if any.
helper context SimpleGT!Rule def : newOutputElements : Sequence(SimpleGT!OutputElement) =
	if self.output.oclIsUndefined() then Sequence{}
	else self.output.newElements endif;

-- Returns all input elements with a name that has not been declared before,
-- i.e. all unique input elements.
helper context SimpleGT!Rule def : allInputElements : Sequence(SimpleGT!InputElement) =
	-- NAC elements are local to each NAC pattern, but input pattern elements are
	-- accessible from each NAC pattern. Therefore, NAC elements that have the same
	-- name as an input element simply refer to the input element.
	self.nac->collect(p|p.elements)->flatten()
		->iterate(e; acc : Sequence(SimpleGT!InputElement) = self.inputElements |
			if self.inputElements->exists(i|i.name = e.name) then acc
			else acc->including(e) endif);

-- Returns all input element patterns that are relevant for the matcher operation.
helper context SimpleGT!Rule def : matcherPatterns : Sequence(SimpleGT!InputElementPattern) =
	self.allInputPatterns->select(p|p.hasBindings or p.hasNewElements); 

-- Returns the original rule input element that any input element refers to.
-- Applies to NAC and output elements that are aliases/repeats of input pattern elements.
helper context SimpleGT!RuleElement def : refersTo : SimpleGT!RuleElement =
	if self.pattern.oclIsKindOf(SimpleGT!InPattern) then
		self
	else
		let inputElements : Sequence(SimpleGT!InputElement) = 
			self.pattern.patternFor.inputElements
			->select(e|e.name = self.name) in
		if inputElements->isEmpty() then
			self
		else
			inputElements->first()
		endif
	endif;

helper context SimpleGT!InPattern def : hasNewElements : Boolean = false;

helper context SimpleGT!NacPattern def : hasNewElements : Boolean =
	self.newElements->notEmpty();

helper context SimpleGT!OutPattern def : hasNewElements : Boolean =
	self.newElements->notEmpty();

helper context SimpleGT!InPattern def : newElements : Sequence(SimpleGT!InputElement) =
	Sequence{};

-- Returns only the contained rule elements that do not occur in the input pattern.
helper context SimpleGT!NacPattern def : newElements : Sequence(SimpleGT!InputElement) =
	let input : SimpleGT!InPattern = self.nacFor.input in
	if input.oclIsUndefined() then
		self.elements
	else
		self.elements->reject(e|input.elements->exists(i|i.name = e.name))
	endif;

-- Returns only the contained rule elements that do not occur in the input pattern.
helper context SimpleGT!OutPattern def : newElements : Sequence(SimpleGT!OutputElement) =
	let input : SimpleGT!InPattern = self.outputFor.input in
	if input.oclIsUndefined() then
		self.elements
	else
		self.elements->reject(e|input.elements->exists(i|i.name = e.name))
	endif;

-- Returns the rule elements that occur in the input pattern, but not in the output pattern.
helper context SimpleGT!Rule def : deletedElements : Sequence(SimpleGT!InputElement) =
	let input : SimpleGT!InPattern = self.input in
	let output : SimpleGT!OutPattern = self.output in
	if input.oclIsUndefined() then
		Sequence{}
	else if output.oclIsUndefined() then
		input.elements
	else
		input.elements->reject(e|output.elements->exists(i|i.name = e.name))
	endif endif;

helper context SimpleGT!OutputElement def : outModelName : String =
	if self.inModel.oclIsUndefined() then
		self.pattern.outputFor."module".models
		->select(m|self.type.model = m.metamodel)
		->first().name
	else
		self.model.name
	endif;

helper context SimpleGT!Rule def : removedBindings : Sequence(SimpleGT!InputBinding) =
	let input : SimpleGT!InPattern = self.input in
	let output : SimpleGT!OutPattern = self.output in
	if input.oclIsUndefined() then
		Sequence{}
	else if output.oclIsUndefined() then
		input.bindings
	else
		input.bindings->reject(ib|output.bindings->exists(ob|
			ob.element.name = ib.element.name and 
			ob.property = ib.property and
			ob.expr.sameAs(ib.expr)))
	endif endif;

helper context SimpleGT!Rule def : addedBindings : Sequence(SimpleGT!OutputBinding) =
	let output : SimpleGT!OutPattern = self.output in
	let input : SimpleGT!InPattern = self.input in
	if output.oclIsUndefined() then
		Sequence{}
	else if input.oclIsUndefined() then
		output.bindings
	else
		output.bindings->reject(ob|input.bindings->exists(ib|
			ob.element.name = ib.element.name and 
			ob.property = ib.property and
			ob.expr.sameAs(ib.expr)))
	endif endif;

helper context OclAny def : sameAs(other : OclAny) : Boolean =
	if (self.oclIsUndefined()) then
		other.oclIsUndefined()
	else
		false
	endif;

helper context SimpleGT!ElementExp def : sameAs(other : SimpleGT!ElementExp) : Boolean =
	self.property = other.property and self.element.name = other.element.name;

helper context SimpleGT!StringLiteralExp def : sameAs(other : SimpleGT!StringLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!IntegerLiteralExp def : sameAs(other : SimpleGT!IntegerLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!DoubleLiteralExp def : sameAs(other : SimpleGT!DoubleLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!BooleanLiteralExp def : sameAs(other : SimpleGT!BooleanLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!CharLiteralExp def : sameAs(other : SimpleGT!CharLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!EnumLiteralExp def : sameAs(other : SimpleGT!EnumLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!Expression def : isUsedInApply : Boolean =
	let parent : OclAny = self.refImmediateComposite() in
	if parent.oclIsKindOf(SimpleGT!Expression) then
		parent.isUsedInApply
	else if parent.oclIsKindOf(SimpleGT!InputBinding) then
		parent.element.pattern.patternFor.removedBindings->includes(parent)
	else
		false
	endif endif;

helper context SimpleGT!InputElementPattern def : accessibleBindings : Sequence(SimpleGT!InputBinding) =
	self.bindings;

helper context SimpleGT!NacPattern def : accessibleBindings : Sequence(SimpleGT!InputBinding) =
	self.bindings->union(self.patternFor.input.bindings);

helper context SimpleGT!InputElement def : isBound : SimpleGT!ElementExp =
	self.pattern.accessibleBindings
		->select(b|b.element <> self and b.expr.oclIsKindOf(SimpleGT!ElementExp))
		->collect(eb|eb.expr)
		->exists(e|e.element = self and e.property.oclIsUndefined());

helper context SimpleGT!InputElement def : bindingExp : SimpleGT!ElementExp =
	self.pattern.accessibleBindings
		->select(b|b.element <> self and b.expr.oclIsKindOf(SimpleGT!ElementExp))
		->collect(eb|eb.expr)
		->select(e|e.element = self and e.property.oclIsUndefined())
		->first();

-- ======================================================================
-- helpers end
-- ======================================================================

-- ======================================================================
-- matched rules begin
-- ======================================================================

rule Module {
	from s : SimpleGT!Module in IN
	to t : EMFTVM!Module (
		name <- s.name,
		sourceName <- s.name + '.simplegt',
		imports <- s.imports,
		inoutModels <- s.models,
		rules <- s.rules,
		features <- Sequence{main}),
	   main : EMFTVM!Operation (
	   	name <- 'main',
		static <- true,
		"context" <- 'ExecEnv',
		contextModel <- 'EMFTVM',
		type <- 'java.lang.Object',
		typeModel <- '#native')
}

rule InstanceModel {
	from s : SimpleGT!InstanceModel in IN
	to t : EMFTVM!ModelDeclaration (
		modelName <- s.name,
		metaModelName <- s.metaModel.name)
}

rule Rule {
	from s : SimpleGT!Rule in IN
	to t : EMFTVM!Rule (
		name <- s.name,
		"abstract" <- s."abstract",
		default <- false,
		distinctElements <- true,
		mode <- #automaticRecursive,
		superRules <- s."extends",
		inputElements <- s.inputElements,
		outputElements <- s.newOutputElements,
		applier <- a),
	   a : EMFTVM!CodeBlock (
	   	localVariables <- Sequence{a_trace}
	   		->union(s.inputElements->collect(e|thisModule.resolveTemp(e, 'ov')))
			->union(s.newOutputElements->collect(e|thisModule.resolveTemp(e, 'ov'))),
		nested <- s.addedBindings->select(b|not b.beforeElement.oclIsUndefined())
			->union(s.removedBindings->collect(r|thisModule.resolveTemp(r, 'cb2')))
			->union(s.addedBindings->select(b|b.beforeElement.oclIsUndefined()))
			->union(s.deletedElements->collect(e|thisModule.resolveTemp(e, 'cb'))),
	   	code <- Sequence{a_invoke_all_cbs}),
	   a_ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{a_invoke_all_cbs}),
	   a_trace : EMFTVM!LocalVariable (
	   	name <- '__trace__',
		type <- 'TraceLink',
		typeModel <- 'TRACE'),
	   a_invoke_all_cbs : EMFTVM!Invoke_all_cbs					-- [null] * nested_cb_size
}

rule RuleWithDebug extends Rule {
	from s : SimpleGT!Rule in IN (
		s."module".debug and
		s.matcherPatterns->isEmpty())
	to t : EMFTVM!Rule,
	   a : EMFTVM!CodeBlock (
	   	code <- Sequence{a_invoke_all_cbs, a_push, a_push2, a_invoke, a_pop}),
	   a_ln : EMFTVM!LineNumber (
		instructions <- Sequence{a_invoke_all_cbs, a_push, a_push2, a_invoke, a_pop}),
	   a_invoke_all_cbs : EMFTVM!Invoke_all_cbs,					-- [null] * nested_cb_size
	   a_push : EMFTVM!Push (stringValue <- 'Applied'),				-- ['Applied', null * nested_cb_size]
	   a_push2 : EMFTVM!Push (stringValue <- s.name),				-- [rule name, 'Applied', null * nested_cb_size]
	   a_invoke : EMFTVM!Invoke (opname <- 'debug', argcount <- 1),	-- [rule name, null * nested_cb_size]
	   a_pop : EMFTVM!Pop											-- [null] * nested_cb_size
}

rule RuleWithMatcher extends Rule {
	from s : SimpleGT!Rule in IN (
		s.matcherPatterns->notEmpty())
	using {
		fp : SimpleGT!InputElementPattern = s.matcherPatterns->first();
		rps : Sequence(SimpleGT!InputElementPattern) = s.matcherPatterns->excluding(fp);
	}
	to t : EMFTVM!Rule (
		matcher <- m),
	   m : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{mln},
	   	localVariables <- s.inputElements
	   		->collect(e|thisModule.resolveTemp(e, 'lv')),
	   	nested <- s.matcherPatterns,
	   	code <- rps->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)),
	   mln : EMFTVM!LineNumber (
	   	startLine <- s.input.line,
		startColumn <- s.input.column,
		startChar <- s.input.charStart,
		endChar <- s.input.charEnd,
	   	instructions <- Sequence{invoke_cb}),
	   invoke_cb : EMFTVM!Invoke_cb  (codeBlock <- fp)					-- [bool]
}

rule RuleWithMatcherWithDebug extends RuleWithMatcher {
	from s : SimpleGT!Rule in IN (
		s."module".debug)
	to t : EMFTVM!Rule,
	   a : EMFTVM!CodeBlock (
	   	code <- Sequence{a_invoke_all_cbs, a_push, a_push2, a_invoke, a_pop}),
	   a_ln : EMFTVM!LineNumber (
		instructions <- Sequence{a_invoke_all_cbs, a_push, a_push2, a_invoke, a_pop}),
	   a_invoke_all_cbs : EMFTVM!Invoke_all_cbs,					-- [null] * nested_cb_size
	   a_push : EMFTVM!Push (stringValue <- 'Applied'),				-- ['Applied', null * nested_cb_size]
	   a_push2 : EMFTVM!Push (stringValue <- s.name),				-- [rule name, 'Applied', null * nested_cb_size]
	   a_invoke : EMFTVM!Invoke (opname <- 'debug', argcount <- 1),	-- [rule name, null * nested_cb_size]
	   a_pop : EMFTVM!Pop											-- [null] * nested_cb_size
}

rule InPattern {
	from s : SimpleGT!InPattern in IN (
		s.hasBindings)
	using {
		fb : SimpleGT!InputBinding = s.bindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.bindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- s.bindings,
		code <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb)			-- [bool]
}

rule InputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.oclIsKindOf(SimpleGT!InPattern))
	to re : EMFTVM!InputRuleElement (
		name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name),
	   ov : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule BoundInputElement extends InputElement {
	from s : SimpleGT!InputElement in IN (
		s.isBound)
	using {
		locals : Sequence(EMFTVM!LocalVariable) =
			s.pattern.elements->collect(e|thisModule.CreateLocal(e));
	}
	to re : EMFTVM!InputRuleElement (
		binding <- bindingCb),
	   bindingCb : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln},
		localVariables <- locals,
	   	code <- Sequence{b_load, b_get}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.bindingExp.line,
		startColumn <- s.bindingExp.column,
		startChar <- s.bindingExp.charStart,
		endChar <- s.bindingExp.charEnd,
		instructions <- Sequence{b_load, b_get}),
	   b_load : EMFTVM!Load (								-- [element]
	   	localVariable <- locals->at(
	   		s.pattern.elements->indexOf(
	   		s.bindingExp.binding.element))),
	   b_get : EMFTVM!Get (									-- [value]
	   	fieldname <- s.bindingExp.binding.property)
}

rule DeletedInputElement extends InputElement {
	from s : SimpleGT!InputElement in IN (
		not s.isBound and
		s.pattern.patternFor.matcherPatterns->isEmpty() and
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule DeletedBoundInputElement extends BoundInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.matcherPatterns->isEmpty() and
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule InputElementWithMatcher extends InputElement {
	from s : SimpleGT!InputElement in IN (
		not s.isBound and
		s.pattern.patternFor.matcherPatterns->notEmpty()) -- no matcher => no lv
	to re : EMFTVM!InputRuleElement,
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule DeletedInputElementWithMatcher extends InputElementWithMatcher {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule BoundInputElementWithMatcher extends BoundInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.matcherPatterns->notEmpty()) -- no matcher => no lv
	to re : EMFTVM!InputRuleElement,
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule DeletedBoundInputElementWithMatcher extends BoundInputElementWithMatcher {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

abstract rule NacPattern {
	from s : SimpleGT!NacPattern in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

rule NacPatternWithNewElements extends NacPattern {
	from s : SimpleGT!NacPattern in IN (
		s.newElements->notEmpty())
	using {
		fe : SimpleGT!InputElement = s.newElements->first();
	}
	to cb : EMFTVM!CodeBlock (
		nested <- Sequence{fe},
		code <- Sequence{invoke_cb}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{invoke_cb}),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fe)			-- [bool]
}

rule NonFirstNacPatternWithNewElements extends NacPatternWithNewElements {
	from s : SimpleGT!NacPattern in IN (
		s <> s.nacFor.matcherPatterns->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule NacPatternWithOnlyBindings extends NacPattern {
	from s : SimpleGT!NacPattern in IN (
		s.newElements->isEmpty() and
		s.hasBindings)
	using {
		fb : SimpleGT!InputBinding = s.bindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.bindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
		localVariables <- s.newElements,
		nested <- s.bindings,
		code <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)->append(not_)),
	   ln : EMFTVM!LineNumber (
	   	instructions <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)->append(not_)),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),			-- [bool]
	   not_ : EMFTVM!Not										-- [bool]
}

rule NonFirstNacPatternWithOnlyBindings extends NacPatternWithOnlyBindings {
	from s : SimpleGT!NacPattern in IN (
		s <> s.nacFor.matcherPatterns->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

abstract rule NacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.oclIsKindOf(SimpleGT!NacPattern) and
		s.pattern.newElements->includes(s))
	to cb : EMFTVM!CodeBlock (
		localVariables <- Sequence{lv},
	   	lineNumbers <- Sequence{ln}),
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,				-- NAC input elements have 'forall' semantics
		typeModel <- s.type.model.name),	-- NAC elements are not available after matching(!)
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd),
	   findtype : EMFTVM!Findtype (
	   	modelname <- s.type.model.name,
		typename <- s.type.name)								-- [type]
}

abstract rule LastNacInputElement extends NacInputElement {
	from s : SimpleGT!InputElement in IN (
		s = s.pattern.newElements->last())
	to cb : EMFTVM!CodeBlock
}

rule TerminatingNacInputElement extends LastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.pattern.hasBindings and
		s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{findtype, allinst, invoke}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{findtype, allinst, invoke}),
	   findtype : EMFTVM!Findtype,									-- [type]
	   allinst : EMFTVM!Allinst,									-- [coll]
	   invoke : EMFTVM!Invoke (opname <- 'isEmpty', argcount <- 0)	-- [bool]
}

rule TerminatingNacInputElementIn extends LastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.pattern.hasBindings and
		not s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{push, findtype, allinst, invoke}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push, findtype, allinst, invoke}),
	   push : EMFTVM!Push (stringValue <- s.inModel.name),			-- [modelname]
	   findtype : EMFTVM!Findtype,									-- [type, modelname]
	   allinst : EMFTVM!Allinst,									-- [coll]
	   invoke : EMFTVM!Invoke (opname <- 'isEmpty', argcount <- 0)	-- [bool]
}

rule LastNacInputElementWithBindings extends LastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasBindings and
		s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.bindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.bindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.bindings,
	   	code <- Sequence{findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   findtype : EMFTVM!Findtype,								-- [type]
	   allinst : EMFTVM!Allinst,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),			-- [bool, it(coll)]
	   ifn : EMFTVM!Ifn (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'true';
	   pushf : EMFTVM!Pushf,									-- [false]		-- invert result
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'false'
	   pusht : EMFTVM!Pusht										-- [true]		-- invert result
}

rule LastNacInputElementWithBindingsIn extends LastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasBindings and
		not s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.bindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.bindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.bindings,
	   	code <- Sequence{push, findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push, findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   push : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname]
	   findtype : EMFTVM!Findtype,								-- [type, modelname]
	   allinst : EMFTVM!Allinst_in,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),			-- [bool, it(coll)]
	   ifn : EMFTVM!Ifn (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'true';
	   pushf : EMFTVM!Pushf,									-- [false]		-- invert result
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'false'
	   pusht : EMFTVM!Pusht										-- [true]		-- invert result
}

rule NacInputElementWithNextElement extends NacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   findtype : EMFTVM!Findtype,								-- [type]
	   allinst : EMFTVM!Allinst,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),		-- [bool, it(coll)]
	   if_ : EMFTVM!If (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'false';
	   pushf : EMFTVM!Pushf,									-- [false]
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'true'
	   pusht : EMFTVM!Pusht										-- [true]
}

rule NacInputElementWithNextElementIn extends NacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		not s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{push, findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push, findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   push : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname]
	   findtype : EMFTVM!Findtype,								-- [type, modelname]
	   allinst : EMFTVM!Allinst,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),		-- [bool, it(coll)]
	   if_ : EMFTVM!If (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'false';
	   pushf : EMFTVM!Pushf,									-- [false]
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'true'
	   pusht : EMFTVM!Pusht										-- [true]
}

rule OutputElement {
	from s : SimpleGT!OutputElement in IN (
		s.pattern.newElements->includes(s)) -- Only elements that should be newly created
	to re : EMFTVM!OutputRuleElement (
		name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name,
		models <- Sequence{s.outModelName}),
	   ov : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule InputBinding {
	from s : SimpleGT!InputBinding in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.expr},
		code <- Sequence{invoke_cb, load, get, invoke}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{invoke_cb, load, get, invoke}),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- s.expr),			-- [expr_val]
	   load : EMFTVM!Load (											-- [element, expr_val]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'lv')),
	   get : EMFTVM!Get (fieldname <- s.property),					-- [prop_val, expr_val]
	   invoke : EMFTVM!Invoke (										-- [bool]
	   	opname <- if s.last then '=~|' else '=~' endif,
		argcount <- 1)
}

rule NonFirstInputBinding extends InputBinding {
	from s : SimpleGT!InputBinding in IN (
		s.element.pattern.patternFor.removedBindings->excludes(s) and
		s <> s.element.pattern.bindings->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule RemovedInputBinding extends InputBinding {
	from s : SimpleGT!InputBinding in IN (
		s.element.pattern.patternFor.removedBindings->includes(s))
	to cb : EMFTVM!CodeBlock,
	   cb2 : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln2},
		nested <- Sequence{thisModule.resolveTemp(s.expr, 'cb2')},
	   	code <- Sequence{invoke_cb2, load2, remove2}),
	   ln2 : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{invoke_cb2, load2, remove2}),
	   invoke_cb2 : EMFTVM!Invoke_cb (								-- [expr_val]
	   	codeBlock <- thisModule.resolveTemp(s.expr, 'cb2')),
	   load2 : EMFTVM!Load (										-- [element, expr_val]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   remove2 : EMFTVM!Remove (fieldname <- s.property)			-- []
}

rule NonFirstRemovedInputBinding extends RemovedInputBinding {
	from s : SimpleGT!InputBinding in IN (
		s <> s.element.pattern.bindings->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule OutputBinding {
	from s : SimpleGT!OutputBinding in IN
	to cb : EMFTVM!CodeBlock (
		nested <- Sequence{s.expr},
		code <- Sequence{invoke_cb, load, add},
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{invoke_cb, load, add}),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- s.expr),			-- [value]
	   load : EMFTVM!Load (											-- [element, value]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   add : EMFTVM!Add (fieldname <- s.property)					-- []
}

rule OutputBindingBeforeElement extends OutputBinding {
	from s : SimpleGT!OutputBinding in IN (
		not s.beforeElement.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		nested <- Sequence{s.expr},
		code <- Sequence{load2, load, dup_x1, get, invoke, invoke_cb, swap_x1, insert},
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load2, load, dup_x1, get, invoke, invoke_cb, swap_x1, insert}),
	   load2 : EMFTVM!Load (										-- [before]
	   	localVariable <- thisModule.resolveTemp(s.beforeElement.refersTo, 'ov')),
	   load : EMFTVM!Load (											-- [element, before]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   dup_x1 : EMFTVM!Dup_x1,										-- [element, before, element]
	   get : EMFTVM!Get (fieldname <- s.property),					-- [oldValue, before, element]
	   invoke : EMFTVM!Invoke (opname <- 'indexOf', argcount <- 1),	-- [index, element]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- s.expr),			-- [value, index, element]
	   swap_x1 : EMFTVM!Swap_x1,									-- [element, value, index]
	   insert : EMFTVM!Insert (fieldname <- s.property)				-- []
}

-------------- Expressions -----------------

abstract rule Expression {
	from s : SimpleGT!Expression in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

abstract rule ExpressionWithApply extends Expression {
	from s : SimpleGT!Expression in IN (
		s.isUsedInApply)
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd),
	   cb2 : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln2}),
	   ln2 : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

rule ElementExp extends Expression {
	from s : SimpleGT!ElementExp in IN (
		not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load}),
	   load : EMFTVM!Load (										-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 
	   		if s.binding.oclIsKindOf(SimpleGT!OutputBinding) 
			then 'ov' 
			else 'lv' endif))
}

rule ElementExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!ElementExp in IN
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load}),
	   load : EMFTVM!Load (										-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 
	   		if s.binding.oclIsKindOf(SimpleGT!OutputBinding) 
			then 'ov' 
			else 'lv' endif)),
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{load2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{load2}),
	   load2 : EMFTVM!Load (									-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov'))
}

rule ElementExpWithProperty extends ElementExp {
	from s : SimpleGT!ElementExp in IN (
		not s.isUsedInApply and
		not s.property.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load, get}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get}),
	   load : EMFTVM!Load,										-- [element]
	   get : EMFTVM!Get (fieldname <- s.property)				-- [propval]
}

rule ElementExpWithApplyWithProperty extends ElementExpWithApply {
	from s : SimpleGT!ElementExp in IN (
		not s.property.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load, get}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get}),
	   load : EMFTVM!Load,										-- [element]
	   get : EMFTVM!Get (fieldname <- s.property),				-- [propval]
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{load2, get2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{load2, get2}),
	   load2 : EMFTVM!Load,										-- [element]
	   get2 : EMFTVM!Get (fieldname <- s.property)				-- [propval]
}

abstract rule LiteralExp extends Expression {
	from s : SimpleGT!LiteralExp in IN (
		not s.isUsedInApply and
		not s.oclIsKindOf(SimpleGT!BooleanLiteralExp))
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Push
}

abstract rule LiteralExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!LiteralExp in IN (
		not s.oclIsKindOf(SimpleGT!BooleanLiteralExp))
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Push,
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Push
}

rule StringLiteralExp extends LiteralExp {
	from s : SimpleGT!StringLiteralExp in IN (not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (stringValue <- s.literal)			-- [string]
}

rule StringLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!StringLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (stringValue <- s.literal),			-- [string]
	   push2 : EMFTVM!Push (stringValue <- s.literal)			-- [string]
}

rule IntegerLiteralExp extends LiteralExp {
	from s : SimpleGT!IntegerLiteralExp in IN (not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (intValue <- s.literal)				-- [int]
}

rule IntegerLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!IntegerLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (intValue <- s.literal),				-- [int]
	   push2 : EMFTVM!Push (intValue <- s.literal)				-- [int]
}

rule DoubleLiteralExp extends LiteralExp {
	from s : SimpleGT!DoubleLiteralExp in IN (not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (doubleValue <- s.literal)			-- [double]
}

rule DoubleLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!DoubleLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (doubleValue <- s.literal),			-- [double]
	   push2 : EMFTVM!Push (doubleValue <- s.literal)			-- [double]
}

rule CharLiteralExp extends LiteralExp {
	from s : SimpleGT!CharLiteralExp in IN (not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (charValue <- s.literal)				-- [char]
}

rule CharLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!CharLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (charValue <- s.literal),				-- [char]
	   push2 : EMFTVM!Push (charValue <- s.literal)				-- [char]
}

rule TrueBooleanLiteralExp extends Expression {
	from s : SimpleGT!BooleanLiteralExp in IN (
		s.literal and not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pusht
}

rule TrueBooleanLiteralExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!BooleanLiteralExp in IN (s.literal)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pusht,
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Pusht
}

rule FalseBooleanLiteralExp extends Expression {
	from s : SimpleGT!BooleanLiteralExp in IN (
		not s.literal and not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pushf
}

rule FalseBooleanLiteralExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!BooleanLiteralExp in IN (not s.literal)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pushf,
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Pushf
}

rule EnumLiteralExp extends LiteralExp {
	from s : SimpleGT!EnumLiteralExp in IN (not s.isUsedInApply)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (enumValue <- s.literal)				-- [enumliteral]
}

rule EnumLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!EnumLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (enumValue <- s.literal),				-- [enumliteral]
	   push2 : EMFTVM!Push (enumValue <- s.literal)				-- [enumliteral]
}

-- ======================================================================
-- matched rules end
-- ======================================================================

-- ======================================================================
-- lazy rules begin
-- ======================================================================

lazy rule CreateLocal {
	from s : SimpleGT!InputElement
	to lv : EMFTVM!LocalVariable (
		name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
	do {
		lv;
	}
}

-- ======================================================================
-- lazy rules end
-- ======================================================================