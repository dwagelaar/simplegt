-- @atlcompiler emftvm
-- @nsURI Problem=http://soft.vub.ac.be/simplegt/2011/Problem
-- @nsURI SimpleGT=http://soft.vub.ac.be/simplegt/2011/SimpleGT
-- @nsURI EMFTVM=http://soft.vub.ac.be/emftvm/2011/EMFTVM
-- Translates SimpleGT transformations to EMFTVM
-- $Id$
module SimpleGTtoEMFTVM;

create OUT : EMFTVM, PBS : Problem from IN : SimpleGT;

-- ======================================================================
-- helpers begin
-- ======================================================================

helper def : CollectionType : String= 'be.ac.vub.emftvm.util.LazyCollection';

helper def : SetType : String		= 'be.ac.vub.emftvm.util.LazySet';
helper def : BagType : String		= 'be.ac.vub.emftvm.util.LazyBag';
helper def : SequenceType : String	= 'be.ac.vub.emftvm.util.LazyList';
helper def : OrderedSetType : String= 'be.ac.vub.emftvm.util.LazyOrderedSet';

helper context SimpleGT!InputElementPattern def : patternFor : SimpleGT!Rule =
	OclUndefined;

helper context SimpleGT!InPattern def : patternFor : SimpleGT!Rule =
	self.inputFor;

helper context SimpleGT!NacPattern def : patternFor : SimpleGT!Rule =
	self.nacFor;

helper context SimpleGT!OutPattern def : patternFor : SimpleGT!Rule =
	self.outputFor;

helper context SimpleGT!Rule def : allInputPatterns : Sequence(SimpleGT!InputElementPattern) =
	if self.input.oclIsUndefined() then
		Sequence{}
	else
		Sequence{self.input}
	endif
	->union(self.nac);

-- Returns 'true' if any contained rule elements have bindings.
helper context SimpleGT!InputElementPattern def : hasBindings : Boolean =
	self.elements->exists(e|e.bindings->notEmpty());

-- Returns all bindings contained in rule elements of this pattern.
helper context SimpleGT!InputElementPattern def : bindings : Sequence(SimpleGT!InputBinding) =
	self.elements->collect(e|e.bindings)->flatten();

-- Returns 'true' if any contained rule elements have bindings.
helper context SimpleGT!OutPattern def : hasBindings : Boolean =
	self.elements->exists(e|e.bindings->notEmpty());

-- Returns all bindings contained in rule elements of this pattern.
helper context SimpleGT!OutPattern def : bindings : Sequence(SimpleGT!OutputBinding) =
	self.elements->collect(e|e.bindings)->flatten();

-- Returns 'true' if the input pattern rule elements have bindings.
helper context SimpleGT!Rule def : hasInputBindings : Boolean =
	self.inputElements->exists(p|p.bindings->notEmpty());

-- Returns input elements contained in the input pattern, if any.
helper context SimpleGT!Rule def : inputElements : Sequence(SimpleGT!InputElement) =
	if self.input.oclIsUndefined() then Sequence{}
	else self.input.elements endif;

-- Returns the output elements contained in the output pattern, if any.
helper context SimpleGT!Rule def : outputElements : Sequence(SimpleGT!OutputElement) =
	if self.output.oclIsUndefined() then Sequence{}
	else self.output.elements endif;

-- Returns the new output elements contained in the output pattern, if any.
helper context SimpleGT!Rule def : newOutputElements : Sequence(SimpleGT!OutputElement) =
	if self.output.oclIsUndefined() then Sequence{}
	else self.output.newElements endif;

-- Returns all input elements with a name that has not been declared before,
-- i.e. all unique input elements.
helper context SimpleGT!Rule def : allInputElements : Sequence(SimpleGT!InputElement) =
	-- NAC elements are local to each NAC pattern, but input pattern elements are
	-- accessible from each NAC pattern. Therefore, NAC elements that have the same
	-- name as an input element simply refer to the input element.
	self.nac->collect(p|p.elements)->flatten()
		->iterate(e; acc : Sequence(SimpleGT!InputElement) = self.inputElements |
			if self.inputElements->exists(i|i.name = e.name) then acc
			else acc->including(e) endif);

-- Returns all input element patterns that are relevant for the matcher operation.
helper context SimpleGT!Rule def : matcherPatterns : Sequence(SimpleGT!InputElementPattern) =
	self.allInputPatterns->select(p|p.hasMatcherBindings or p.hasNewElements); 

-- Returns the original rule input element that any input element refers to.
-- Applies to NAC and output elements that are aliases/repeats of input pattern elements.
helper context SimpleGT!RuleElement def : refersTo : SimpleGT!RuleElement =
	if self.pattern.oclIsKindOf(SimpleGT!InPattern) then
		self
	else
		let inputElements : Sequence(SimpleGT!InputElement) = 
			self.pattern.patternFor.inputElements
			->select(e|e.name = self.name) in
		if inputElements->isEmpty() then
			self
		else
			inputElements->first()
		endif
	endif;

helper context SimpleGT!InPattern def : hasNewElements : Boolean = false;

helper context SimpleGT!NacPattern def : hasNewElements : Boolean =
	self.newElements->notEmpty();

helper context SimpleGT!OutPattern def : hasNewElements : Boolean =
	self.newElements->notEmpty();

helper context SimpleGT!InPattern def : newElements : Sequence(SimpleGT!InputElement) =
	Sequence{};

-- Returns only the contained rule elements that do not occur in the input pattern.
helper context SimpleGT!NacPattern def : newElements : Sequence(SimpleGT!InputElement) =
	let elements : Sequence(SimpleGT!InputElement) =
		let input : SimpleGT!InPattern = self.nacFor.input in
		if input.oclIsUndefined() then
			self.elements
		else
			self.elements->reject(e|input.elements->exists(i|i.name = e.name))
		endif
	in
	elements->reject(e|e.isBound)->union(elements->select(e|e.isBound));

-- Returns only the contained rule elements that do not occur in the input pattern.
helper context SimpleGT!OutPattern def : newElements : Sequence(SimpleGT!OutputElement) =
	let input : SimpleGT!InPattern = self.outputFor.input in
	if input.oclIsUndefined() then
		self.elements
	else
		self.elements->reject(e|input.elements->exists(i|i.name = e.name))
	endif;

-- Returns the rule elements that occur in the input pattern, but not in the output pattern.
helper context SimpleGT!Rule def : deletedElements : Sequence(SimpleGT!InputElement) =
	let input : SimpleGT!InPattern = self.input in
	let output : SimpleGT!OutPattern = self.output in
	if input.oclIsUndefined() then
		Sequence{}
	else if output.oclIsUndefined() then
		input.elements
	else
		input.elements->reject(e|output.elements->exists(i|i.name = e.name))
	endif endif;

helper context SimpleGT!OutputElement def : outModelName : String =
	if self.inModel.oclIsUndefined() then
		self.pattern.outputFor."module".models
		->select(m|self.type.model = m.metamodel)
		->first().name
	else
		self.model.name
	endif;

helper context SimpleGT!Rule def : removedBindings : Sequence(SimpleGT!InputBinding) =
	let input : SimpleGT!InPattern = self.input in
	let output : SimpleGT!OutPattern = self.output in
	if input.oclIsUndefined() then
		Sequence{}
	else if output.oclIsUndefined() then
		input.bindings
	else
		input.bindings->reject(ib|output.bindings->exists(ob|
			ob.element.name = ib.element.name and
			ob.property = ib.property and
			ob.expr.sameAs(ib.expr)))
	endif endif;

helper context SimpleGT!Rule def : addedBindings : Sequence(SimpleGT!OutputBinding) =
	let output : SimpleGT!OutPattern = self.output in
	let input : SimpleGT!InPattern = self.input in
	if output.oclIsUndefined() then
		Sequence{}
	else if input.oclIsUndefined() then
		output.bindings
	else
		output.bindings->reject(ob|input.bindings->exists(ib|
			ob.element.name = ib.element.name and 
			ob.property = ib.property and
			ob.expr.sameAs(ib.expr)))
	endif endif;

helper context OclAny def : sameAs(other : OclAny) : Boolean =
	if (self.oclIsUndefined()) then
		other.oclIsUndefined()
	else
		false
	endif;

helper context SimpleGT!ElementExp def : sameAs(other : SimpleGT!ElementExp) : Boolean =
	self.property = other.property and self.element.name = other.element.name;

helper context SimpleGT!StringLiteralExp def : sameAs(other : SimpleGT!StringLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!IntegerLiteralExp def : sameAs(other : SimpleGT!IntegerLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!DoubleLiteralExp def : sameAs(other : SimpleGT!DoubleLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!BooleanLiteralExp def : sameAs(other : SimpleGT!BooleanLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!CharLiteralExp def : sameAs(other : SimpleGT!CharLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!EnumLiteralExp def : sameAs(other : SimpleGT!EnumLiteralExp) : Boolean =
	self.literal = other.literal;

helper context SimpleGT!Expression def : isUsed : Boolean =
	let parent : SimpleGT!Binding = self.binding in
	if parent.oclIsKindOf(SimpleGT!InputBinding) then
		not parent.isElementBinding
	else if parent.oclIsKindOf(SimpleGT!OutputBinding) then
		parent.element.pattern.patternFor.addedBindings->includes(parent)
	else
		false
	endif endif;

helper context SimpleGT!Expression def : isUsedTwice : Boolean =
	let parent : SimpleGT!Binding = self.binding in
	if parent.oclIsKindOf(SimpleGT!InputBinding) then
		parent.element.pattern.patternFor.removedBindings->includes(parent)
	else
		false
	endif;

helper context SimpleGT!InputElementPattern def : accessibleBindings : Sequence(SimpleGT!InputBinding) =
	self.bindings;

helper context SimpleGT!NacPattern def : accessibleBindings : Sequence(SimpleGT!InputBinding) =
	self.bindings->union(self.patternFor.input.bindings);

helper context SimpleGT!InputElement def : isBound : Boolean =
	self.pattern.accessibleBindings
		->select(b|b.element <> self and b.expr.oclIsKindOf(SimpleGT!ElementExp))
		->collect(eb|eb.expr)
		->exists(e|e.element = self and e.property.oclIsUndefined());

helper context SimpleGT!InputElement def : bindingExp : SimpleGT!ElementExp =
	self.pattern.accessibleBindings
		->select(b|b.element <> self and b.expr.oclIsKindOf(SimpleGT!ElementExp))
		->collect(eb|eb.expr)
		->select(e|e.element = self and e.property.oclIsUndefined())
		->first();

-- Whether self binds the value of another input element
helper context SimpleGT!InputBinding def : isElementBinding : Boolean =
	self.element.pattern.patternFor.allInputElements
		->exists(e|e.isBound and e.bindingExp.binding = self);

helper context SimpleGT!InputElement def : matcherBindings : Sequence(SimpleGT!InputBinding) =
	self.bindings->reject(b|b.isElementBinding);

-- Returns 'true' if any contained rule elements have matcher bindings.
helper context SimpleGT!InputElementPattern def : hasMatcherBindings : Boolean =
	self.elements->exists(e|e.matcherBindings->notEmpty());

-- Returns all matcher bindings contained in rule elements of this pattern.
helper context SimpleGT!InputElementPattern def : matcherBindings : Sequence(SimpleGT!InputBinding) =
	self.elements->collect(e|e.matcherBindings)->flatten();

-- ======================================================================
-- helpers end
-- ======================================================================

-- ======================================================================
-- matched rules begin
-- ======================================================================

rule Module {
	from s : SimpleGT!Module in IN
	to t : EMFTVM!Module (
		name <- s.name,
		sourceName <- s.name + '.simplegt',
		imports <- s.imports,
		inoutModels <- s.models,
		rules <- s.rules,
		features <- Sequence{main}),
	   main : EMFTVM!Operation (
	   	name <- 'main',
		static <- true,
		"context" <- 'ExecEnv',
		contextModel <- 'EMFTVM',
		type <- 'java.lang.Object',
		typeModel <- '#native')
}

rule InstanceModel {
	from s : SimpleGT!InstanceModel in IN
	to t : EMFTVM!ModelDeclaration (
		modelName <- s.name,
		metaModelName <- s.metaModel.name)
}

rule Rule {
	from s : SimpleGT!Rule in IN
	to t : EMFTVM!Rule (
		name <- s.name,
		"abstract" <- s."abstract",
		default <- false,
		distinctElements <- true,
		mode <- #automaticRecursive,
		superRules <- s."extends",
		inputElements <- s.inputElements,
		outputElements <- s.newOutputElements,
		applier <- a),
	   a : EMFTVM!CodeBlock (
	   	localVariables <- Sequence{a_trace}
	   		->union(s.inputElements->collect(e|thisModule.resolveTemp(e, 'ov')))
			->union(s.newOutputElements->collect(e|thisModule.resolveTemp(e, 'ov'))),
		lineNumbers <- Sequence{a_ln},
		nested <- s.addedBindings->select(b|not b.beforeElement.oclIsUndefined())
			->union(s.removedBindings->collect(r|thisModule.resolveTemp(r, 'cb2')))
			->union(s.addedBindings->select(b|b.beforeElement.oclIsUndefined()))
			->union(s.deletedElements->collect(e|thisModule.resolveTemp(e, 'cb'))),
	   	code <- Sequence{a_invoke_all_cbs}),
	   a_ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{a_invoke_all_cbs}),
	   a_trace : EMFTVM!LocalVariable (
	   	name <- '__trace__',
		type <- 'TraceLink',
		typeModel <- 'TRACE'),
	   a_invoke_all_cbs : EMFTVM!Invoke_all_cbs					-- [null] * nested_cb_size
}

rule RuleWithDebug extends Rule {
	from s : SimpleGT!Rule in IN (
		s."module".debug and
		s.matcherPatterns->isEmpty())
	to t : EMFTVM!Rule,
	   a : EMFTVM!CodeBlock (
	   	code <- Sequence{a_invoke_all_cbs, a_push, a_load, a_invoke, a_pop}),
	   a_ln : EMFTVM!LineNumber (
		instructions <- Sequence{a_invoke_all_cbs, a_push, a_load, a_invoke, a_pop}),
	   a_trace : EMFTVM!LocalVariable,
	   a_invoke_all_cbs : EMFTVM!Invoke_all_cbs,							-- [null] * nested_cb_size
	   a_push : EMFTVM!Push (stringValue <- 'Applied ' + s.name + ' to'),	-- ['Applied...', null * nested_cb_size]
	   a_load : EMFTVM!Load (localVariable <- a_trace),						-- [trace, 'Applied...', null * nested_cb_size]
	   a_invoke : EMFTVM!Invoke (opname <- 'debug', argcount <- 1),			-- [trace, null * nested_cb_size]
	   a_pop : EMFTVM!Pop													-- [null] * nested_cb_size
}

rule RuleWithMatcher extends Rule {
	from s : SimpleGT!Rule in IN (
		s.matcherPatterns->notEmpty())
	using {
		fp : SimpleGT!InputElementPattern = s.matcherPatterns->first();
		rps : Sequence(SimpleGT!InputElementPattern) = s.matcherPatterns->excluding(fp);
	}
	to t : EMFTVM!Rule (
		matcher <- m),
	   m : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{mln},
	   	localVariables <- s.inputElements
	   		->collect(e|thisModule.resolveTemp(e, 'lv')),
	   	nested <- s.matcherPatterns,
	   	code <- rps->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)),
	   mln : EMFTVM!LineNumber (
	   	startLine <- s.input.line,
		startColumn <- s.input.column,
		startChar <- s.input.charStart,
		endChar <- s.input.charEnd,
	   	instructions <- Sequence{invoke_cb}),
	   invoke_cb : EMFTVM!Invoke_cb  (codeBlock <- fp)					-- [bool]
}

rule RuleWithMatcherWithDebug extends RuleWithMatcher {
	from s : SimpleGT!Rule in IN (
		s."module".debug)
	to t : EMFTVM!Rule,
	   a : EMFTVM!CodeBlock (
	   	code <- Sequence{a_invoke_all_cbs, a_push, a_load, a_invoke, a_pop}),
	   a_ln : EMFTVM!LineNumber (
		instructions <- Sequence{a_invoke_all_cbs, a_push, a_load, a_invoke, a_pop}),
	   a_trace : EMFTVM!LocalVariable,
	   a_invoke_all_cbs : EMFTVM!Invoke_all_cbs,							-- [null] * nested_cb_size
	   a_push : EMFTVM!Push (stringValue <- 'Applied ' + s.name + ' to'),	-- ['Applied...', null * nested_cb_size]
	   a_load : EMFTVM!Load (localVariable <- a_trace),						-- [trace, 'Applied...', null * nested_cb_size]
	   a_invoke : EMFTVM!Invoke (opname <- 'debug', argcount <- 1),			-- [rule name, null * nested_cb_size]
	   a_pop : EMFTVM!Pop													-- [null] * nested_cb_size
}

rule InPattern {
	from s : SimpleGT!InPattern in IN (
		s.hasMatcherBindings)
	using {
		fb : SimpleGT!InputBinding = s.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- s.matcherBindings,
		code <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb)			-- [bool]
}

rule InputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.oclIsKindOf(SimpleGT!InPattern))
	to re : EMFTVM!InputRuleElement (
		name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name),
	   ov : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule BoundInputElement extends InputElement {
	from s : SimpleGT!InputElement in IN (
		s.isBound)
	using {
		locals : Sequence(EMFTVM!LocalVariable) =
			s.pattern.elements->collect(e|thisModule.CreateLocal(e));
	}
	to re : EMFTVM!InputRuleElement (
		binding <- bindingCb),
	   bindingCb : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln},
		localVariables <- locals,
	   	code <- Sequence{b_load, b_get}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.bindingExp.line,
		startColumn <- s.bindingExp.column,
		startChar <- s.bindingExp.charStart,
		endChar <- s.bindingExp.charEnd,
		instructions <- Sequence{b_load, b_get}),
	   b_load : EMFTVM!Load (								-- [element]
	   	localVariable <- locals->at(
	   		s.pattern.elements->indexOf(
	   		s.bindingExp.binding.element))),
	   b_get : EMFTVM!Get (									-- [value]
	   	fieldname <- s.bindingExp.binding.property)
}

rule LastBoundInputElement extends BoundInputElement {
	from s : SimpleGT!InputElement in IN (
		s.bindingExp.binding.last)
	using {
		locals : Sequence(EMFTVM!LocalVariable) =
			s.pattern.elements->collect(e|thisModule.CreateLocal(e));
	}
	to re : EMFTVM!InputRuleElement,
	   bindingCb : EMFTVM!CodeBlock (
	   	code <- Sequence{b_load, b_get, b_dup, b_findtype, b_swap, b_invoke, b_ifn, b_dup2, b_invoke2, b_if, b_invoke3, b_ret}),
	   ln : EMFTVM!LineNumber (
		instructions <- Sequence{b_load, b_get, b_dup, b_findtype, b_swap, b_invoke, b_ifn, b_dup2, b_invoke2, b_if, b_invoke3, b_ret}),
	   b_load : EMFTVM!Load,								-- [element]
	   b_get : EMFTVM!Get,									-- [values]
	   b_dup : EMFTVM!Dup,									-- [values, values]
	   b_findtype : EMFTVM!Findtype (						-- [type, values, values]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   b_swap : EMFTVM!Swap,								-- [values, type, values]
	   b_invoke : EMFTVM!Invoke (							-- [bool, values]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   b_ifn : EMFTVM!Ifn (target <- b_ret),				-- [values]
	   b_dup2 : EMFTVM!Dup,									-- [values, values]
	   b_invoke2 : EMFTVM!Invoke (							-- [bool, values]
	   	opname <- 'isEmpty', argcount <- 0),
	   b_if : EMFTVM!If (target <- b_ret),					-- [values]
	   b_invoke3 : EMFTVM!Invoke (							-- [value]
	   	opname <- 'last', argcount <- 0),
	   b_ret : EMFTVM!Return								-- []
}

rule DeletedInputElement extends InputElement {
	from s : SimpleGT!InputElement in IN (
		not s.isBound and
		s.pattern.patternFor.matcherPatterns->isEmpty() and
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule DeletedBoundInputElement extends BoundInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.matcherPatterns->isEmpty() and
		s.pattern.patternFor.deletedElements->includes(s) and
		not s.bindingExp.binding.last)
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule DeletedLastBoundInputElement extends LastBoundInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.matcherPatterns->isEmpty() and
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule InputElementWithMatcher extends InputElement {
	from s : SimpleGT!InputElement in IN (
		not s.isBound and
		s.pattern.patternFor.matcherPatterns->notEmpty()) -- no matcher => no lv
	to re : EMFTVM!InputRuleElement,
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule DeletedInputElementWithMatcher extends InputElementWithMatcher {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule BoundInputElementWithMatcher extends BoundInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.bindingExp.binding.last and
		s.pattern.patternFor.matcherPatterns->notEmpty()) -- no matcher => no lv
	to re : EMFTVM!InputRuleElement,
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule DeletedBoundInputElementWithMatcher extends BoundInputElementWithMatcher {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

rule LastBoundInputElementWithMatcher extends LastBoundInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.matcherPatterns->notEmpty()) -- no matcher => no lv
	to re : EMFTVM!InputRuleElement,
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule DeletedLastBoundInputElementWithMatcher extends LastBoundInputElementWithMatcher {
	from s : SimpleGT!InputElement in IN (
		s.pattern.patternFor.deletedElements->includes(s))
	to re : EMFTVM!InputRuleElement,
	   ov : EMFTVM!LocalVariable,
	   cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		code <- Sequence{load, del}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{load, del}),
	   load : EMFTVM!Load (localVariable <- ov),		-- [element]
	   del : EMFTVM!Delete								-- []
}

abstract rule NacPattern {
	from s : SimpleGT!NacPattern in IN
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

rule NacPatternWithNewElements extends NacPattern {
	from s : SimpleGT!NacPattern in IN (
		s.hasNewElements)
	using {
		fe : SimpleGT!InputElement = s.newElements->first();
	}
	to cb : EMFTVM!CodeBlock (
		nested <- Sequence{fe},
		code <- Sequence{invoke_cb}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{invoke_cb}),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fe)			-- [bool]
}

rule NonFirstNacPatternWithNewElements extends NacPatternWithNewElements {
	from s : SimpleGT!NacPattern in IN (
		s <> s.nacFor.matcherPatterns->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule NacPatternWithOnlyBindings extends NacPattern {
	from s : SimpleGT!NacPattern in IN (
		not s.hasNewElements and
		s.hasBindings)
	using {
		fb : SimpleGT!InputBinding = s.bindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.bindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
		localVariables <- s.newElements,
		nested <- s.bindings,
		code <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)->append(not_)),
	   ln : EMFTVM!LineNumber (
	   	instructions <- rbs->collect(b|thisModule.resolveTemp(b, 'and_'))
			->prepend(invoke_cb)->append(not_)),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),			-- [bool]
	   not_ : EMFTVM!Not										-- [bool]
}

rule NonFirstNacPatternWithOnlyBindings extends NacPatternWithOnlyBindings {
	from s : SimpleGT!NacPattern in IN (
		s <> s.nacFor.matcherPatterns->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule EmptyNacPattern extends NacPattern {
	from s : SimpleGT!NacPattern in IN (
		s.newElements->isEmpty() and
		not s.hasBindings)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{pushf}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{pushf}),
	   pushf : EMFTVM!Pushf										-- [bool]
}

abstract rule NacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.oclIsKindOf(SimpleGT!NacPattern) and
		s.pattern.newElements->includes(s))
	to cb : EMFTVM!CodeBlock (
		localVariables <- Sequence{lv},
	   	lineNumbers <- Sequence{ln}),
	   lv : EMFTVM!LocalVariable (
	   	name <- s.name,
		type <- s.type.name,				-- NAC input elements have 'forall' semantics
		typeModel <- s.type.model.name),	-- NAC elements are not available after matching(!)
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

abstract rule UnboundNacInputElement extends NacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.isBound)
	to cb : EMFTVM!CodeBlock,
	   findtype : EMFTVM!Findtype (
	   	modelname <- s.type.model.name,
		typename <- s.type.name)									-- [type]
}

abstract rule BoundNacInputElement extends NacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.isBound)
	to cb : EMFTVM!CodeBlock,
	   load : EMFTVM!Load (											-- [element]
	   	localVariable <- thisModule.resolveTemp(
	   		s.bindingExp.binding.element.refersTo, 'lv')),
	   get : EMFTVM!Get (											-- [values]
	   	fieldname <- s.bindingExp.binding.property),
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype (									-- [type, values, values]
	   	modelname <- '#native',
		typename <- thisModule.CollectionType),
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke (										-- [bool, values]
	   	opname <- 'oclIsKindOf', argcount <- 1)
}

abstract rule LastBoundNacInputElement extends BoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.bindingExp.binding.last)
	to cb : EMFTVM!CodeBlock,
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn,											-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype (								-- [type, values, values]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke (									-- [bool, values]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn_s : EMFTVM!Ifn,											-- [values]
	   invoke_last : EMFTVM!Invoke (								-- [value]
	   	opname <- 'last', argcount <- 0)
}

abstract rule UnboundLastNacInputElement extends UnboundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s = s.pattern.newElements->last())
	to cb : EMFTVM!CodeBlock
}

abstract rule BoundLastNacInputElement extends BoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.bindingExp.binding.last and
		s = s.pattern.newElements->last())
	to cb : EMFTVM!CodeBlock
}

abstract rule LastBoundLastNacInputElement extends LastBoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s = s.pattern.newElements->last())
	to cb : EMFTVM!CodeBlock
}

rule TerminatingNacInputElement extends UnboundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.pattern.hasMatcherBindings and
		s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{findtype, allinst, invoke}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{findtype, allinst, invoke}),
	   findtype : EMFTVM!Findtype,									-- [type]
	   allinst : EMFTVM!Allinst,									-- [coll]
	   invoke : EMFTVM!Invoke (opname <- 'isEmpty', argcount <- 0)	-- [bool]
}

rule TerminatingNacInputElementIn extends UnboundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.pattern.hasMatcherBindings and
		not s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{push, findtype, allinst, invoke}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push, findtype, allinst, invoke}),
	   push : EMFTVM!Push (stringValue <- s.inModel.name),			-- [modelname]
	   findtype : EMFTVM!Findtype,									-- [type, modelname]
	   allinst : EMFTVM!Allinst_in,									-- [coll]
	   invoke : EMFTVM!Invoke (opname <- 'isEmpty', argcount <- 0)	-- [bool]
}

rule BoundTerminatingNacInputElement extends BoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.pattern.hasMatcherBindings and
		s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, it, findtype2, swap2, invoke2, if_, endit, pushf, goto, pop, pusht, goto2, findtype3, swap3, invoke3, not_}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, it, findtype2, swap2, invoke2, if_, endit, pushf, goto, pop, pusht, goto2, findtype3, swap3, invoke3, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- findtype3),						-- [values]
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	   goto2 : EMFTVM!Goto (target <- not_),						-- [true]
	-- value is single
	   findtype3 : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap3 : EMFTVM!Swap,											-- [value, type]
	   invoke3 : EMFTVM!Invoke (									-- [bool]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule BoundTerminatingNacInputElementIn extends BoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		not s.pattern.hasMatcherBindings and
		not s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, it, dup2, findtype2, swap2, invoke2, ifn2, push_m, swap_m, invoke_m, if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, goto2, dup3, findtype3, swap3, invoke3, ifn3, push_mv, swap_mv, invoke_mv, goto3, pop_v, pushf_v, not_}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, it, dup2, findtype2, swap2, invoke2, ifn2, push_m, swap_m, invoke_m, if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, goto2, dup3, findtype3, swap3, invoke3, ifn3, push_mv, swap_mv, invoke_mv, goto3, pop_v, pushf_v, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- dup3),							-- [values]
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   push_m : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value, it(values)]
	   swap_m : EMFTVM!Swap,										-- [value, modelname, it(values)]
	   invoke_m : EMFTVM!Invoke (									-- [bool, it(values)]
	   	opname <- 'isInModel', argcount <- 1),
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	   goto2 : EMFTVM!Goto (target <- not_),						-- [true]
	-- value is single
	   dup3 : EMFTVM!Dup,											-- [value, value]
	   findtype3 : EMFTVM!Findtype (								-- [type, value, value]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap3 : EMFTVM!Swap,											-- [value, type, value]
	   invoke3 : EMFTVM!Invoke (									-- [bool, value]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn3 : EMFTVM!Ifn (target <- pop_v),							-- [value]
	   push_mv : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value]
	   swap_mv : EMFTVM!Swap,										-- [value, modelname]
	   invoke_mv : EMFTVM!Invoke (									-- [bool]
	   	opname <- 'isInModel', argcount <- 1),
	   goto3 : EMFTVM!Goto (target <- not_),						-- [bool]
	   pop_v : EMFTVM!Pop,											-- []
	   pushf_v : EMFTVM!Pushf,										-- [false]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastBoundTerminatingNacInputElement extends BoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.bindingExp.binding.last and
		not s.pattern.hasMatcherBindings and
		s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, goto_s, it, findtype2, swap2, invoke2, if_, endit, pushf, goto, pop, pusht, goto2, findtype3, swap3, invoke3, not_}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, goto_s, it, findtype2, swap2, invoke2, if_, endit, pushf, goto, pop, pusht, goto2, findtype3, swap3, invoke3, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- findtype3),						-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype,								-- [type, values, values]
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke,									-- [bool, values]
	   ifn_s : EMFTVM!Ifn (target <- it),							-- [values]
	   invoke_last : EMFTVM!Invoke,									-- [value]
	   goto_s : EMFTVM!Goto	(target <- findtype3),					-- [value]
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	   goto2 : EMFTVM!Goto (target <- not_),						-- [true]
	-- value is single
	   findtype3 : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap3 : EMFTVM!Swap,											-- [value, type]
	   invoke3 : EMFTVM!Invoke (									-- [bool]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastBoundTerminatingNacInputElementIn extends BoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.bindingExp.binding.last and
		not s.pattern.hasMatcherBindings and
		not s.inModel.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, goto_s, it, dup2, findtype2, swap2, invoke2, ifn2, push_m, swap_m, invoke_m, if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, goto2, dup3, findtype3, swap3, invoke3, ifn3, push_mv, swap_mv, invoke_mv, goto3, pop_v, pushf_v, not_}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, goto_s, it, dup2, findtype2, swap2, invoke2, ifn2, push_m, swap_m, invoke_m, if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, goto2, dup3, findtype3, swap3, invoke3, ifn3, push_mv, swap_mv, invoke_mv, goto3, pop_v, pushf_v, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- dup3),							-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype,								-- [type, values, values]
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke,									-- [bool, values]
	   ifn_s : EMFTVM!Ifn (target <- it),							-- [values]
	   invoke_last : EMFTVM!Invoke,									-- [value]
	   goto_s : EMFTVM!Goto	(target <- dup3),						-- [value]
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   push_m : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value, it(values)]
	   swap_m : EMFTVM!Swap,										-- [value, modelname, it(values)]
	   invoke_m : EMFTVM!Invoke (									-- [bool, it(values)]
	   	opname <- 'isInModel', argcount <- 1),
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	   goto2 : EMFTVM!Goto (target <- not_),						-- [true]
	-- value is single
	   dup3 : EMFTVM!Dup,											-- [value, value]
	   findtype3 : EMFTVM!Findtype (								-- [type, value, value]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap3 : EMFTVM!Swap,											-- [value, type, value]
	   invoke3 : EMFTVM!Invoke (									-- [bool, value]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn3 : EMFTVM!Ifn (target <- pop_v),							-- [value]
	   push_mv : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value]
	   swap_mv : EMFTVM!Swap,										-- [value, modelname]
	   invoke_mv : EMFTVM!Invoke (									-- [bool]
	   	opname <- 'isInModel', argcount <- 1),
	   goto3 : EMFTVM!Goto (target <- not_),						-- [bool]
	   pop_v : EMFTVM!Pop,											-- []
	   pushf_v : EMFTVM!Pushf,										-- [false]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastNacInputElementWithBindings extends UnboundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasMatcherBindings and
		s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.matcherBindings,
	   	code <- Sequence{findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   findtype : EMFTVM!Findtype,								-- [type]
	   allinst : EMFTVM!Allinst,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),			-- [bool, it(coll)]
	   ifn : EMFTVM!Ifn (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'true';
	   pushf : EMFTVM!Pushf,									-- [false]		-- invert result
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'false'
	   pusht : EMFTVM!Pusht										-- [true]		-- invert result
}

rule LastNacInputElementWithBindingsIn extends UnboundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasMatcherBindings and
		not s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.matcherBindings,
	   	code <- Sequence{push, findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push, findtype, allinst, it, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{ifn, pop, pushf, ret, endit, pusht})),
	   push : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname]
	   findtype : EMFTVM!Findtype,								-- [type, modelname]
	   allinst : EMFTVM!Allinst_in,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),			-- [bool, it(coll)]
	   ifn : EMFTVM!Ifn (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'true';
	   pushf : EMFTVM!Pushf,									-- [false]		-- invert result
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'false'
	   pusht : EMFTVM!Pusht										-- [true]		-- invert result
}

rule BoundLastNacInputElementWithBindings extends BoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasMatcherBindings and
		s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.matcherBindings,
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   if_c : EMFTVM!If (target <- it),								-- [values]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),				-- [bool, it(values)]
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule BoundLastNacInputElementWithBindingsIn extends BoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasMatcherBindings and
		not s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.matcherBindings,
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   if_c : EMFTVM!If (target <- it),								-- [values]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   dup3 : EMFTVM!Dup,											-- [value, value, it(values)]
	   push_m : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value, value, it(values)]
	   swap_m : EMFTVM!Swap,										-- [value, modelname, value, it(values)]
	   invoke_m : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'isInModel', argcount <- 1),
	   ifn3 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),				-- [bool, it(values)]
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastBoundLastNacInputElementWithBindings extends LastBoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasMatcherBindings and
		s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.matcherBindings,
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- findtype_c),						-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype,								-- [type, values, values]
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke,									-- [bool, values]
	   ifn_s : EMFTVM!Ifn (target <- it),							-- [values]
	   invoke_last : EMFTVM!Invoke,									-- [value]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),				-- [bool, it(values)]
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastBoundLastNacInputElementWithBindingsIn extends LastBoundLastNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s.pattern.hasMatcherBindings and
		not s.inModel.oclIsUndefined())
	using {
		fb : SimpleGT!InputBinding = s.pattern.matcherBindings->first();
		rbs : Sequence(SimpleGT!InputBinding) = s.pattern.matcherBindings->excluding(fb);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- s.pattern.matcherBindings,
	   	code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb}
	   		->union(rbs->collect(b|thisModule.resolveTemp(b, 'and_')))
			->union(Sequence{if_, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_})),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- findtype_c),						-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype,								-- [type, values, values]
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke,									-- [bool, values]
	   ifn_s : EMFTVM!Ifn (target <- it),							-- [values]
	   invoke_last : EMFTVM!Invoke,									-- [value]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   dup3 : EMFTVM!Dup,											-- [value, value, it(values)]
	   push_m : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value, value, it(values)]
	   swap_m : EMFTVM!Swap,										-- [value, modelname, value, it(values)]
	   invoke_m : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'isInModel', argcount <- 1),
	   ifn3 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- fb),				-- [bool, it(values)]
	   if_ : EMFTVM!If (target <- pop),								-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule NacInputElementWithNextElement extends UnboundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   findtype : EMFTVM!Findtype,								-- [type]
	   allinst : EMFTVM!Allinst,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),		-- [bool, it(coll)]
	   if_ : EMFTVM!If (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'false';
	   pushf : EMFTVM!Pushf,									-- [false]
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'true'
	   pusht : EMFTVM!Pusht										-- [true]
}

rule NacInputElementWithNextElementIn extends UnboundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		not s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{push, findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push, findtype, allinst, it, store, invoke_cb, if_, pop, pushf, ret, endit, pusht}),
	   push : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname]
	   findtype : EMFTVM!Findtype,								-- [type, modelname]
	   allinst : EMFTVM!Allinst_in,								-- [coll]
	   it : EMFTVM!Iterate (target <- endit),					-- [inst, it(coll)]
	   store : EMFTVM!Store (localVariable <- lv),				-- [it(coll)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),		-- [bool, it(coll)]
	   if_ : EMFTVM!If (target <- endit),						-- [it(coll)]
	   pop : EMFTVM!Pop,										-- []			-- invoke_cb returned 'false';
	   pushf : EMFTVM!Pushf,									-- [false]
	   ret : EMFTVM!Return,										-- false, []
	   endit : EMFTVM!Enditerate (target <- it),				-- []			-- invoke_cb returned 'true'
	   pusht : EMFTVM!Pusht										-- [true]
}

rule BoundNacInputElementWithNextElement extends BoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb, ifn3, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb, ifn3, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   if_c : EMFTVM!Ifn (target <- it),							-- [values]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),			-- [bool, it(values)]
	   ifn3 : EMFTVM!If (target <- pop),							-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule BoundNacInputElementWithNextElementIn extends BoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		not s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb, ifn4, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, if_c, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb, ifn4, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   if_c : EMFTVM!Ifn (target <- it),							-- [values]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   dup3 : EMFTVM!Dup,											-- [value, value, it(values)]
	   push_m : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value, value, it(values)]
	   swap_m : EMFTVM!Swap,										-- [value, modelname, value, it(values)]
	   invoke_m : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'isInModel', argcount <- 1),
	   ifn3 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),			-- [bool, it(values)]
	   ifn4 : EMFTVM!If (target <- pop),							-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastBoundNacInputElementWithNextElement extends LastBoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb, ifn3, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, store, invoke_cb, ifn3, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- findtype_c),						-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype,								-- [type, values, values]
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke,									-- [bool, values]
	   ifn_s : EMFTVM!Ifn (target <- it),							-- [values]
	   invoke_last : EMFTVM!Invoke,									-- [value]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),			-- [bool, it(values)]
	   ifn3 : EMFTVM!If (target <- pop),							-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule LastBoundNacInputElementWithNextElementIn extends LastBoundNacInputElement {
	from s : SimpleGT!InputElement in IN (
		s <> s.pattern.newElements->last() and
		not s.inModel.oclIsUndefined())
	using {
		next : SimpleGT!InputElement =
			s.pattern.newElements->at(s.pattern.newElements->indexOf(s)+1);
	}
	to cb : EMFTVM!CodeBlock (
	   	nested <- Sequence{next},
		code <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb, ifn4, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   lv : EMFTVM!LocalVariable,
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get, dup, findtype, swap, invoke, ifn, dup_s, findtype_s, swap_s, invoke_s, ifn_s, invoke_last, findtype_c, new_c, invoke_c, it, dup2, findtype2, swap2, invoke2, ifn2, dup3, push_m, swap_m, invoke_m, ifn3, store, invoke_cb, ifn4, goto_endit, pop_endit, endit, pushf, goto, pop, pusht, not_}),
	   load : EMFTVM!Load,											-- [element]
	   get : EMFTVM!Get,											-- [values]
	   dup : EMFTVM!Dup,											-- [values, values]
	   findtype : EMFTVM!Findtype,									-- [type, values, values]
	   swap : EMFTVM!Swap,											-- [values, type, values]
	   invoke : EMFTVM!Invoke,										-- [bool, values]
	   ifn : EMFTVM!Ifn (target <- findtype_c),						-- [values]
	   dup_s : EMFTVM!Dup,											-- [values, values]
	   findtype_s : EMFTVM!Findtype,								-- [type, values, values]
	   swap_s : EMFTVM!Swap,										-- [values, type, values]
	   invoke_s : EMFTVM!Invoke,									-- [bool, values]
	   ifn_s : EMFTVM!Ifn (target <- it),							-- [values]
	   invoke_last : EMFTVM!Invoke,									-- [value]
	-- value is single; wrap in collection
	   findtype_c : EMFTVM!Findtype (								-- [type, value]
	   	modelname <- '#native',
		typename <- thisModule.SequenceType),
	   new_c : EMFTVM!New,											-- [coll, value]
	   invoke_c : EMFTVM!Invoke (									-- [values]
	   	opname <- 'append', argcount <- 1),
	-- value is a collection
	   it : EMFTVM!Iterate (target <- endit),						-- [value, it(values)]
	   dup2 : EMFTVM!Dup,											-- [value, value, it(values)]
	   findtype2 : EMFTVM!Findtype (								-- [type, value, value, it(values)]
	   	modelname <- s.type.model.name,
		typename <- s.type.name),
	   swap2 : EMFTVM!Swap,											-- [value, type, value, it(values)]
	   invoke2 : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'oclIsKindOf', argcount <- 1),
	   ifn2 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   dup3 : EMFTVM!Dup,											-- [value, value, it(values)]
	   push_m : EMFTVM!Push (stringValue <- s.inModel.name),		-- [modelname, value, value, it(values)]
	   swap_m : EMFTVM!Swap,										-- [value, modelname, value, it(values)]
	   invoke_m : EMFTVM!Invoke (									-- [bool, value, it(values)]
	   	opname <- 'isInModel', argcount <- 1),
	   ifn3 : EMFTVM!Ifn (target <- pop_endit),						-- [value, it(values)]
	   store : EMFTVM!Store (localVariable <- lv),					-- [it(values)]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- next),			-- [bool, it(values)]
	   ifn4 : EMFTVM!If (target <- pop),							-- [it(values)]
	   goto_endit : EMFTVM!Goto (target <- endit),					-- [it(values)]
	   pop_endit : EMFTVM!Pop,										-- [it(values)]
	   endit : EMFTVM!Enditerate (target <- it),					-- []
	   pushf : EMFTVM!Pushf,										-- [false]
	   goto : EMFTVM!Goto (target <- not_),							-- [true]
	   pop : EMFTVM!Pop,											-- []
	   pusht : EMFTVM!Pusht,										-- [true]
	-- invert
	   not_ : EMFTVM!Not											-- [bool]
}

rule OutputElement {
	from s : SimpleGT!OutputElement in IN (
		s.pattern.newElements->includes(s)) -- Only elements that should be newly created
	to re : EMFTVM!OutputRuleElement (
		name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name,
		models <- Sequence{s.outModelName}),
	   ov : EMFTVM!LocalVariable (
	   	name <- s.varName,
		type <- s.type.name,
		typeModel <- s.type.model.name)
}

rule InputBinding {
	from s : SimpleGT!InputBinding in IN (
		not s.isElementBinding)
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln},
		nested <- Sequence{s.expr},
		code <- Sequence{invoke_cb, load, get, invoke}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{invoke_cb, load, get, invoke}),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- s.expr),			-- [expr_val]
	   load : EMFTVM!Load (											-- [element, expr_val]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'lv')),
	   get : EMFTVM!Get (fieldname <- s.property),					-- [prop_val, expr_val]
	   invoke : EMFTVM!Invoke (										-- [bool]
	   	opname <- if s.last then '=~|' else '=~' endif,
		argcount <- 1)
}

rule NonFirstInputBinding extends InputBinding {
	from s : SimpleGT!InputBinding in IN (
		s.element.pattern.patternFor.removedBindings->excludes(s) and
		s <> s.element.pattern.matcherBindings->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule RemovedInputBinding extends InputBinding {
	from s : SimpleGT!InputBinding in IN (
		s.element.pattern.patternFor.removedBindings->includes(s))
	to cb : EMFTVM!CodeBlock,
	   cb2 : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln2},
		nested <- Sequence{thisModule.resolveTemp(s.expr, 'cb2')},
	   	code <- Sequence{invoke_cb2, load2, remove2}),
	   ln2 : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{invoke_cb2, load2, remove2}),
	   invoke_cb2 : EMFTVM!Invoke_cb (								-- [expr_val]
	   	codeBlock <- thisModule.resolveTemp(s.expr, 'cb2')),
	   load2 : EMFTVM!Load (										-- [element, expr_val]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   remove2 : EMFTVM!Remove (fieldname <- s.property)			-- []
}

rule NonFirstRemovedInputBinding extends RemovedInputBinding {
	from s : SimpleGT!InputBinding in IN (
		s <> s.element.pattern.matcherBindings->first())
	to cb : EMFTVM!CodeBlock,
	   and_ : EMFTVM!And (codeBlock <- cb)	-- AND instruction for parent code block
}

rule RemovedInputElementBinding { -- only used in applier
	from s : SimpleGT!InputBinding in IN (
		s.isElementBinding and
		s.element.pattern.patternFor.removedBindings->includes(s))
	to cb2 : EMFTVM!CodeBlock (
	   	lineNumbers <- Sequence{ln2},
		nested <- Sequence{thisModule.resolveTemp(s.expr, 'cb2')},
	   	code <- Sequence{invoke_cb2, load2, remove2}),
	   ln2 : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd,
		instructions <- Sequence{invoke_cb2, load2, remove2}),
	   invoke_cb2 : EMFTVM!Invoke_cb (								-- [expr_val]
	   	codeBlock <- thisModule.resolveTemp(s.expr, 'cb2')),
	   load2 : EMFTVM!Load (										-- [element, expr_val]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   remove2 : EMFTVM!Remove (fieldname <- s.property)			-- []
}

abstract rule OutputBinding {
	from s : SimpleGT!OutputBinding in IN (
		s.element.pattern.patternFor.addedBindings->includes(s))
	to cb : EMFTVM!CodeBlock (
		nested <- Sequence{s.expr},
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

rule SimpleOutputBinding extends OutputBinding {
	from s : SimpleGT!OutputBinding in IN (
		s.beforeElement.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{invoke_cb, load, add}),
	   ln : EMFTVM!LineNumber (
		instructions <- Sequence{invoke_cb, load, add}),
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- s.expr),			-- [value]
	   load : EMFTVM!Load (											-- [element, value]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   add : EMFTVM!Add (fieldname <- s.property)					-- []
}

rule OutputBindingBeforeElement extends OutputBinding {
	from s : SimpleGT!OutputBinding in IN (
		not s.beforeElement.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load2, load, dup_x1, get, invoke, invoke_cb, swap_x1, insert}),
	   ln : EMFTVM!LineNumber (
		instructions <- Sequence{load2, load, dup_x1, get, invoke, invoke_cb, swap_x1, insert}),
	   load2 : EMFTVM!Load (										-- [before]
	   	localVariable <- thisModule.resolveTemp(s.beforeElement.refersTo, 'ov')),
	   load : EMFTVM!Load (											-- [element, before]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov')),
	   dup_x1 : EMFTVM!Dup_x1,										-- [element, before, element]
	   get : EMFTVM!Get (fieldname <- s.property),					-- [oldValue, before, element]
	   invoke : EMFTVM!Invoke (opname <- 'indexOf', argcount <- 1),	-- [index, element]
	   invoke_cb : EMFTVM!Invoke_cb (codeBlock <- s.expr),			-- [value, index, element]
	   swap_x1 : EMFTVM!Swap_x1,									-- [element, value, index]
	   insert : EMFTVM!Insert (fieldname <- s.property)				-- []
}

-------------- Expressions -----------------

abstract rule Expression {
	from s : SimpleGT!Expression in IN (
		s.isUsed)
	to cb : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln}),
	   ln : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

abstract rule ExpressionWithApply extends Expression {
	from s : SimpleGT!Expression in IN (
		s.isUsedTwice)
	to cb : EMFTVM!CodeBlock,
	   ln : EMFTVM!LineNumber,
	   cb2 : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln2}),
	   ln2 : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

abstract rule ExpressionWithOnlyApply {
	from s : SimpleGT!Expression in IN (
		not s.isUsed and s.isUsedTwice)
	to cb2 : EMFTVM!CodeBlock (
		lineNumbers <- Sequence{ln2}),
	   ln2 : EMFTVM!LineNumber (
	   	startLine <- s.line,
		startColumn <- s.column,
		startChar <- s.charStart,
		endChar <- s.charEnd)
}

rule ElementExp extends Expression {
	from s : SimpleGT!ElementExp in IN (
		not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load}),
	   load : EMFTVM!Load (										-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 
	   		if s.binding.oclIsKindOf(SimpleGT!OutputBinding) 
			then 'ov' 
			else 'lv' endif))
}

rule ElementExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!ElementExp in IN
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load}),
	   load : EMFTVM!Load (										-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 
	   		if s.binding.oclIsKindOf(SimpleGT!OutputBinding) 
			then 'ov' 
			else 'lv' endif)),
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{load2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{load2}),
	   load2 : EMFTVM!Load (									-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov'))
}

rule ElementExpWithOnlyApply extends ExpressionWithOnlyApply {
	from s : SimpleGT!ElementExp in IN
	to cb2 : EMFTVM!CodeBlock (
		code <- Sequence{load2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{load2}),
	   load2 : EMFTVM!Load (									-- [element]
	   	localVariable <- thisModule.resolveTemp(s.element.refersTo, 'ov'))
}

rule ElementExpWithProperty extends ElementExp {
	from s : SimpleGT!ElementExp in IN (
		not s.isUsedTwice and
		not s.property.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load, get}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get}),
	   load : EMFTVM!Load,										-- [element]
	   get : EMFTVM!Get (fieldname <- s.property)				-- [propval]
}

rule ElementExpWithApplyWithProperty extends ElementExpWithApply {
	from s : SimpleGT!ElementExp in IN (
		not s.property.oclIsUndefined())
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{load, get}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{load, get}),
	   load : EMFTVM!Load,										-- [element]
	   get : EMFTVM!Get (fieldname <- s.property),				-- [propval]
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{load2, get2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{load2, get2}),
	   load2 : EMFTVM!Load,										-- [element]
	   get2 : EMFTVM!Get (fieldname <- s.property)				-- [propval]
}

rule ElementExpWithOnlyApplyWithProperty extends ElementExpWithOnlyApply {
	from s : SimpleGT!ElementExp in IN (
		not s.property.oclIsUndefined())
	to cb2 : EMFTVM!CodeBlock (
		code <- Sequence{load2, get2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{load2, get2}),
	   load2 : EMFTVM!Load,										-- [element]
	   get2 : EMFTVM!Get (fieldname <- s.property)				-- [propval]
}

abstract rule LiteralExp extends Expression {
	from s : SimpleGT!LiteralExp in IN (
		not s.isUsedTwice and
		not s.oclIsKindOf(SimpleGT!BooleanLiteralExp))
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Push
}

abstract rule LiteralExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!LiteralExp in IN (
		not s.oclIsKindOf(SimpleGT!BooleanLiteralExp))
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Push,
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Push
}

abstract rule LiteralExpWithOnlyApply extends ExpressionWithOnlyApply {
	from s : SimpleGT!LiteralExp in IN (
		not s.oclIsKindOf(SimpleGT!BooleanLiteralExp))
	to cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Push
}

rule StringLiteralExp extends LiteralExp {
	from s : SimpleGT!StringLiteralExp in IN (not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (stringValue <- s.literal)			-- [string]
}

rule StringLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!StringLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (stringValue <- s.literal),			-- [string]
	   push2 : EMFTVM!Push (stringValue <- s.literal)			-- [string]
}

rule StringLiteralExpWithOnlyApply extends LiteralExpWithOnlyApply {
	from s : SimpleGT!StringLiteralExp in IN
	to cb2 : EMFTVM!CodeBlock,
	   push2 : EMFTVM!Push (stringValue <- s.literal)			-- [string]
}

rule IntegerLiteralExp extends LiteralExp {
	from s : SimpleGT!IntegerLiteralExp in IN (not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (intValue <- s.literal)				-- [int]
}

rule IntegerLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!IntegerLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (intValue <- s.literal),				-- [int]
	   push2 : EMFTVM!Push (intValue <- s.literal)				-- [int]
}

rule IntegerLiteralExpWithOnlyApply extends LiteralExpWithOnlyApply {
	from s : SimpleGT!IntegerLiteralExp in IN
	to cb2 : EMFTVM!CodeBlock,
	   push2 : EMFTVM!Push (intValue <- s.literal)				-- [int]
}

rule DoubleLiteralExp extends LiteralExp {
	from s : SimpleGT!DoubleLiteralExp in IN (not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (doubleValue <- s.literal)			-- [double]
}

rule DoubleLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!DoubleLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (doubleValue <- s.literal),			-- [double]
	   push2 : EMFTVM!Push (doubleValue <- s.literal)			-- [double]
}

rule DoubleLiteralExpWithOnlyApply extends LiteralExpWithOnlyApply {
	from s : SimpleGT!DoubleLiteralExp in IN
	to cb2 : EMFTVM!CodeBlock,
	   push2 : EMFTVM!Push (doubleValue <- s.literal)			-- [double]
}

rule CharLiteralExp extends LiteralExp {
	from s : SimpleGT!CharLiteralExp in IN (not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (charValue <- s.literal)				-- [char]
}

rule CharLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!CharLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (charValue <- s.literal),				-- [char]
	   push2 : EMFTVM!Push (charValue <- s.literal)				-- [char]
}

rule CharLiteralExpWithOnlyApply extends LiteralExpWithOnlyApply {
	from s : SimpleGT!CharLiteralExp in IN
	to cb2 : EMFTVM!CodeBlock,
	   push2 : EMFTVM!Push (charValue <- s.literal)				-- [char]
}

rule TrueBooleanLiteralExp extends Expression {
	from s : SimpleGT!BooleanLiteralExp in IN (
		s.literal and not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pusht
}

rule TrueBooleanLiteralExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!BooleanLiteralExp in IN (s.literal)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pusht,
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Pusht
}

rule TrueBooleanLiteralExpWithOnlyApply extends ExpressionWithOnlyApply {
	from s : SimpleGT!BooleanLiteralExp in IN (s.literal)
	to cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Pusht
}

rule FalseBooleanLiteralExp extends Expression {
	from s : SimpleGT!BooleanLiteralExp in IN (
		not s.literal and not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pushf
}

rule FalseBooleanLiteralExpWithApply extends ExpressionWithApply {
	from s : SimpleGT!BooleanLiteralExp in IN (not s.literal)
	to cb : EMFTVM!CodeBlock (
		code <- Sequence{push}),
	   ln : EMFTVM!LineNumber (
	   	instructions <- Sequence{push}),
	   push : EMFTVM!Pushf,
	   cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Pushf
}

rule FalseBooleanLiteralExpWithOnlyApply extends ExpressionWithOnlyApply {
	from s : SimpleGT!BooleanLiteralExp in IN (not s.literal)
	to cb2 : EMFTVM!CodeBlock (
		code <- Sequence{push2}),
	   ln2 : EMFTVM!LineNumber (
	   	instructions <- Sequence{push2}),
	   push2 : EMFTVM!Pushf
}

rule EnumLiteralExp extends LiteralExp {
	from s : SimpleGT!EnumLiteralExp in IN (not s.isUsedTwice)
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (enumValue <- s.literal)				-- [enumliteral]
}

rule EnumLiteralExpWithApply extends LiteralExpWithApply {
	from s : SimpleGT!EnumLiteralExp in IN
	to cb : EMFTVM!CodeBlock,
	   push : EMFTVM!Push (enumValue <- s.literal),				-- [enumliteral]
	   push2 : EMFTVM!Push (enumValue <- s.literal)				-- [enumliteral]
}

rule EnumLiteralExpWithOnlyApply extends LiteralExpWithOnlyApply {
	from s : SimpleGT!EnumLiteralExp in IN
	to cb2 : EMFTVM!CodeBlock,
	   push2 : EMFTVM!Push (enumValue <- s.literal)				-- [enumliteral]
}

-- ======================================================================
-- matched rules end
-- ======================================================================

-- ======================================================================
-- lazy rules begin
-- ======================================================================

lazy rule CreateLocal {
	from s : SimpleGT!InputElement
	to lv : EMFTVM!LocalVariable (
		name <- s.name,
		type <- s.type.name,
		typeModel <- s.type.model.name)
	do {
		lv;
	}
}

-- ======================================================================
-- lazy rules end
-- ======================================================================